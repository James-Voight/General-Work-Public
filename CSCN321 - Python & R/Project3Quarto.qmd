---
title: "EDA & Visualization Assignment"
author: "James Voight"
date: "09-22-2024"
date-format: long
format:
  #pdf
  #pptx
  #docx:
    #reference-doc: knowles-custom-reference-doc.docx # make sure it is in the same folder as the .qmd
      # Run this in your python terminal to create a basic reference-doc that you can modify:
      # quarto pandoc -o custom-reference-doc.docx --print-default-data-file reference.docx
  html: # or docx for Word Document
    toc: true # includes table of contents
    code-fold: true # option for collapsing code blocks in html
execute:
  echo: true # includes output
  warning: false # turns off warnings
  error: false # if set to true, then stops running at error
  output: true
python:
  version: "3.12.4"  # Specify your Python version here
  
---

# R Code
```{r}
# Load/Install necessary libraries
# install.packages("readr")
# install.packages("readxl")
# install.packages("dplyr")
# install.packages("tidyr")
# install.packages("ggplot2")

library(readr)
library(readxl)
library(dplyr)
library(tidyr)
library(ggplot2)
```

# Python Code
```{python}

```

## Q1a - Python
```{python}
# 1. Loop 1: Calculate Test Scores

answers = ['A', 'B', 'C', 'D', 'C', 'D', 'A', 'C', 'C', 'B', 'D', 'A', 'B', 'D', 'C', 'D', 'A', 'D', 'C', 'A', 'B', 'D', 'C', 'C', 'A']
student_1 = ['A', 'B', 'C', 'A', 'B', 'D', 'A', 'A', 'C', 'B', 'D', 'A', 'D', 'C', 'C', 'B', 'C', 'D', 'B', 'A', 'D', 'D', 'C', 'C', 'A']
student_2 = ['D', 'A', 'C', 'A', 'B', 'D', 'A', 'C', 'C', 'B', 'D', 'A', 'B', 'D', 'A', 'D', 'C', 'D', 'C', 'A', 'B', 'C', 'C', 'B', 'A']

grade_1 = grade_2 = 0

for i in range(len(answers)):
    if student_1[i] == answers[i]:
        grade_1 += 1
    if student_2[i] == answers[i]:
        grade_2 += 1

grade_1 = (grade_1 / len(answers)) * 100
grade_2 = (grade_2 / len(answers)) * 100

print(f"Student 1 grade: {grade_1:.0f}%")
print(f"Student 2 grade: {grade_2:.0f}%")
```

## Q1a - R
```{r}
# 1. Loop 1: Calculate Test Scores

answers <- c('A', 'B', 'C', 'D', 'C', 'D', 'A', 'C', 'C', 'B', 'D', 'A', 'B', 'D', 'C', 'D', 'A', 'D', 'C', 'A', 'B', 'D', 'C', 'C', 'A')
student_1 <- c('A', 'B', 'C', 'A', 'B', 'D', 'A', 'A', 'C', 'B', 'D', 'A', 'D', 'C', 'C', 'B', 'C', 'D', 'B', 'A', 'D', 'D', 'C', 'C', 'A')
student_2 <- c('D', 'A', 'C', 'A', 'B', 'D', 'A', 'C', 'C', 'B', 'D', 'A', 'B', 'D', 'A', 'D', 'C', 'D', 'C', 'A', 'B', 'C', 'C', 'B', 'A')

grade_1 <- grade_2 <- 0

for (i in 1:length(answers)) {
  if (student_1[i] == answers[i]) {
    grade_1 <- grade_1 + 1
  }
  if (student_2[i] == answers[i]) {
    grade_2 <- grade_2 + 1
  }
}

grade_1 <- (grade_1 / length(answers)) * 100
grade_2 <- (grade_2 / length(answers)) * 100

cat(sprintf("Student 1 grade: %.0f%%\n", grade_1))
cat(sprintf("Student 2 grade: %.0f%%\n", grade_2))
``` 

## Q2a - Python
```{python}
# 2. Loop 2: Price Bulk Orders

quantities = [88, 126, 126, 100, 186, 200, 216, 250]

for quantity in quantities:
    if quantity <= 100:
        cost = quantity * 250
    elif quantity <= 200:
        cost = 100 * 250 + (quantity - 100) * 225
    else:
        cost = 100 * 250 + 100 * 225 + (quantity - 200) * 200
    
    print(f"The cost for an order of {quantity} gadgets is ${cost}.")
```

## Q2a - R
```{r}
# 2. Loop 2: Price Bulk Orders

quantities <- c(88, 126, 126, 100, 186, 200, 216, 250)

for (quantity in quantities) {
  if (quantity <= 100) {
    cost <- quantity * 250
  } else if (quantity <= 200) {
    cost <- 100 * 250 + (quantity - 100) * 225
  } else {
    cost <- 100 * 250 + 100 * 225 + (quantity - 200) * 200
  }
  
  cat(sprintf("The cost for an order of %d gadgets is $%d.\n", quantity, cost))
}
``` 

## Q3a - Python
```{python}
# 3. Loop 3: Create an Amortization Schedule

balance = 220000
i = 0.006  # 0.6% monthly interest rate
payment = 220000 * (0.006 * (1 + 0.006)**360) / ((1 + 0.006)**360 - 1) #comes out to about $1493.33
months = 360

for month in range(1, months + 1):
    interest = balance * i
    principal = payment - interest
    balance = balance - principal
    
    if month % 12 == 0:
        print(f"The balance at the end of {month} months will be ${balance:.2f}.")
```

## Q3a - R
```{r}
# 3. Loop 3: Create an Amortization Schedule

balance <- 220000
i <- 0.006  # 0.6% monthly interest rate
payment <- 220000 * (0.006 * (1 + 0.006)**360) / ((1 + 0.006)**360 - 1) #comes out to about $1493.33
months <- 360

for (month in 1:months) {
  interest <- balance * i
  principal <- payment - interest
  balance <- balance - principal
  
  if (month %% 12 == 0) {
    cat(sprintf("The balance at the end of %d months will be $%.2f.\n", month, balance))
  }
}
``` 

## Q4a - Python
```{python}
# 4. Function 1: Dot Product

def dot_product(x, y):
    return sum(a * b for a, b in zip(x, y))

list1 = [25, 9, 43, 34, 20, 14, 42, 36, 12, 1, 23, 46, 31, 9, 30, 33, 16, 43, 24, 41]
list2 = [38, 11, 35, 13, 26, 3, 36, 15, 42, 38, 45, 10, 17, 6, 47, 31, 38, 41, 31, 27]

result = dot_product(list1, list2)
print(f"The dot product of list1 and list2 is {result}.")
```

## Q4a - R
```{r}
# 4. Function 1: Dot Product

dot_product <- function(x, y) {
  return(sum(x * y))
}

list1 <- c(25, 9, 43, 34, 20, 14, 42, 36, 12, 1, 23, 46, 31, 9, 30, 33, 16, 43, 24, 41)
list2 <- c(38, 11, 35, 13, 26, 3, 36, 15, 42, 38, 45, 10, 17, 6, 47, 31, 38, 41, 31, 27)

result <- dot_product(list1, list2)
cat(sprintf("The dot product of list1 and list2 is %d.\n", result))
``` 

## Q5a - Python
```{python}
# 5. Function 2: Index of Smallest Element

def mindex(x):
    min_index = 0
    for i in range(1, len(x)):
        if x[i] < x[min_index]:
            min_index = i
    return min_index

list3 = ['Richmond', 'Charlotte', 'New York', 'Phoenix', 'Juneau', 'Denver', 'Charlotte']

print(f"Index of smallest element in list1: {mindex(list1)}")
print(f"Index of smallest element in list2: {mindex(list2)}")
print(f"Index of smallest element in list3: {mindex(list3)}")
```

## Q5a - R
```{r}
#5. Function: Index of Smallest Element

mindex <- function(x) {
  if (is.numeric(x)) {
    min_index <- which.min(x)
  } else {
    min_index <- which(x == min(x))[1]
  }
  return(min_index - 1) # Adjust for zero-based indexing in Python
}

list3 <- c('Richmond', 'Charlotte', 'New York', 'Phoenix', 'Juneau', 'Denver', 'Charlotte')

cat(sprintf("Index of smallest element in list1: %d\n", mindex(list1)))
cat(sprintf("Index of smallest element in list2: %d\n", mindex(list2)))
cat(sprintf("Index of smallest element in list3: %d\n", mindex(list3)))
``` 

## Q6a - Python
```{python}
# 6. Function 3: Unique Values

def un(x):
    unique = []
    for item in x:
        if item not in unique:
            unique.append(item)
    return sorted(unique)

print(f"Unique values in list1: {un(list1)}")
print(f"Unique values in list2: {un(list2)}")
print(f"Unique values in list3: {un(list3)}")
```

## Q6a - R
```{r}

#6. Function: Unique Values

un <- function(x) {
  result <- c()
  for (item in x) {
    if (!(item %in% result)) {
      result <- c(result, item)
    }
  }
  return(sort(result))
}

cat("Unique values in list1:", un(list1), "\n")
cat("Unique values in list2:", un(list2), "\n")
cat("Unique values in list3:", un(list3), "\n")
``` 

## Q7a - Python
```{python}
# 7. Function 4: Weighted Mean

def w_mean(v, w=None):
    if w is None:
        return sum(v) / len(v)
    else:
        return round(sum(x * y for x, y in zip(v, w)) / sum(w), 2)

values = [2, 7, 4, 5, 2, 6, 7, 2, 4, 9]
weights = [1, 4, 3, 1, 2, 3, 1, 3, 2, 2]

print(f"Simple mean of values: {w_mean(values)}")
print(f"Weighted mean of values: {w_mean(values, weights)}")
```

## Q7a - R
```{r}
#7. Function: Weighted Mean

w_mean <- function(v, w = NULL) {
    if (is.null(w)) {
        # Simple mean without using built-in mean() function
        return(sum(v) / length(v))
    } else {
        # Weighted mean
        weighted_mean <- sum(v * w) / sum(w)
        return(round(weighted_mean, digits = 2))
    }
}

values = c(2,7,4,5,2,6,7,2,4,9)
weights = c(1,4 ,3 ,1 ,2 ,3 ,1 ,3,2,2)

cat(sprintf("Simple mean of values: %.2f\n", w_mean(values)))
cat(sprintf("Weighted mean of values: %.2f\n", w_mean(values , weights)))
``` 

## Q8a - Python
```{python}
# 8. Function 5: Intersection

def inter(array1, array2):
    set1 = set(array1)
    set2 = set(array2)
    return sorted(list(set1.intersection(set2)))

array_A = [4, 6, 8, 2, 1, 7, 9, 1]
array_B = [6, 2, 4, 9, 2, 4, 4, 6, 2, 2]
array_C = [0, 1, 9, 6, -6, 0]

print(f"Intersection of values and weights: {inter(values, weights)}")
print(f"Intersection of array_A and array_B: {inter(array_A, array_B)}")
print(f"Intersection of array_C and array_A: {inter(array_C, array_A)}")

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
```

## Q8a - R
```{r}
#8. Function: Intersection

inter <- function(array1, array2) {
  result <- c()
  for (item in array1) {
    if (item %in% array2 && !(item %in% result)) {
      result <- c(result, item)
    }
  }
  return(sort(result))
}

array_A = c(4 ,6 ,8 ,2 ,1 ,7 ,9 ,1)
array_B = c(6 ,2 ,4 ,9 ,2 ,4 ,4 ,6 ,2)
array_C = c(0 ,1 ,9 ,6 ,-6)

cat("Intersection of values and weights:", inter(values , weights), "\n")
cat("Intersection of array_A and array_B:", inter(array_A,array_B), "\n")
cat("Intersection of array_C and array_A:", inter(array_C,array_A), "\n")

library(readr)
library(readxl)
library(dplyr)
library(ggplot2)
``` 

## Q9a - Python
```{python}
# 9. Function 6: Load Data

import pandas as pd

def load_data(file_name):
    file_extension = file_name.split('.')[-1].lower()

    if file_extension == 'csv':
        return pd.read_csv(f'C:/Users/james/Desktop/Fall 2024 code/321/homework/project3/TestSets/{file_name}')
    elif file_extension == 'txt':
        return pd.read_csv(f'C:/Users/james/Desktop/Fall 2024 code/321/homework/project3/TestSets/{file_name}', sep='\t')
    elif file_extension in ['xls', 'xlsx']:
        return pd.read_excel(f'C:/Users/james/Desktop/Fall 2024 code/321/homework/project3/TestSets/{file_name}')
    else:
        raise ValueError("Unsupported file extension. Please use .csv, .txt, .xls, or .xlsx files.")

# Test the function
for file in ['test.csv', 'Test.txt', 'test.xlsx']:
    df = load_data(file)
    print(f"\nHead of {file}:")
    print(df.head())
```

## Q9a - R
```{r}
# 9. Function: Load Data

library(readr)
library(readxl)

load_data <- function(file_name){
    file_extension <- tools::file_ext(file_name)
    
    if (file_extension == 'csv'){
        return(read_csv(paste0('C:/Users/james/Desktop/Fall 2024 code/321/homework/project3/TestSets/', file_name)))
    } else if (file_extension == 'txt'){
        return(read_delim(paste0('C:/Users/james/Desktop/Fall 2024 code/321/homework/project3/TestSets/', file_name), "\t"))
    } else if (file_extension %in% c('xls', 'xlsx')){
        return(read_excel(paste0('C:/Users/james/Desktop/Fall 2024 code/321/homework/project3/TestSets/', file_name)))
    } else{
        stop("Unsupported file extension. Please use .csv, .txt, .xls or .xlsx files.")
    }
}

# Test the function
for (file in c('test.csv', 'test.txt', 'test.xlsx')) {
    df <- load_data(file)
    cat(sprintf("\nHead of %s:\n", file))
    print(head(df))
}
``` 

## Q10a - Python
```{python}
# 10. Function 7: Clean Data

def clean_data(df, col=None, method='dropna', val=None):
    if method == 'dropna':
        return df.dropna(subset=[col] if col else None)

    elif method == 'fill_na':
        if col:
            if val == 'locf':
                df[col] = df[col].fillna(method='ffill')
            elif val == 'nocb':
                df[col] = df[col].fillna(method='bfill')
            elif val == 'mean':
                df[col] = df[col].fillna(df[col].mean())
            else:
                df[col] = df[col].fillna(0)
            return df
        else:
            # If no column is specified, apply to all columns
            return df.fillna(0)
    
    elif method == 'scale':
        if col:
            scaler = StandardScaler()
            df[col] = scaler.fit_transform(df[[col]])
            return df
        else:
            raise ValueError("Column must be specified for scaling.")
    
    else:
        raise ValueError("Unsupported method. Use 'dropna', 'fill_na', or 'scale'.")

# Test the function
df = load_data('test.csv')
print("\nOriginal data:")
print(df.head())

print("\nAfter dropping NA:")
print(clean_data(df, method='dropna').head())

print("\nAfter filling NA with none:")
print(clean_data(df, col='Quantity', method='fill_na', val='none').head())

print("\nAfter filling NA with locf:")
print(clean_data(df, col='CustomerID', method='fill_na', val='locf').head())

print("\nAfter filling NA with nocb:")
print(clean_data(df, col='Country', method='fill_na', val='nocb').head())

print("\nAfter filling NA with mean:")
print(clean_data(df, col='Age', method='fill_na', val='mean').head())

print("\nAfter scaling:")
print(clean_data(df, col='Price', method='scale').head())
```

## Q10a - R
```{r}
#10. Function: Clean Data

clean_data <- function(df,col=NULL,
                       method='dropna',
                       val=NULL){
    
    if (method == 'dropna'){
        df_cleaned = df %>% drop_na(col)
        
    } else if (method == 'fill_na'){
        
        if (!is.null(col)){
            if (val == 'locf'){
                df_cleaned = df %>% fill(col,.direction='down')
            } else if (val == 'nocb'){
                df_cleaned = df %>% fill(col,.direction='up')
            } else if (val == 'mean'){
                mean_value = mean(df[[col]], na.rm=TRUE)
                df_cleaned = df %>% mutate({{col}} := replace_na({{col}},mean_value))
            } else{
                df_cleaned = df %>% mutate({{col}} := replace_na({{col}},0))
            }
        } else{
            df_cleaned = df %>% mutate_all(~replace_na(.x,val=0))
        }
        
    } else if (method == 'scale') {
        if (!is.null(col)) {
            if (!is.numeric(df[[col]])) {
                warning(paste("Column", col, "is not numeric. Attempting to convert."))
                df[[col]] <- as.numeric(as.character(df[[col]]))
            }
            df_cleaned <- df %>% 
                mutate(across(all_of(col), ~scale(as.numeric(.))))
        } else {
            stop("Column must be specified for scaling.")
        }
        
    } else{
        stop("Unsupported method.Use dropna or fill_na.")
    }
    
    return(df_cleaned)
}

# Test the function
df <- load_data('test.csv')
print("\nOriginal data:")
print(head(df))

print("\nAfter dropping NA:")
print(head(clean_data(df, method='dropna')))

print("\nAfter filling NA with none:")
print(head(clean_data(df, col='Quantity', method='fill_na', val='none')))

print("\nAfter filling NA with locf:")
print(head(clean_data(df, col='CustomerID', method='fill_na', val='locf')))

print("\nAfter filling NA with nocb:")
print(head(clean_data(df, col='Country', method='fill_na', val='nocb')))

print("\nAfter filling NA with mean:")
print(head(clean_data(df, col='Age', method='fill_na', val='mean')))

print("\nAfter scaling:")
print(head(clean_data(df, col='Price', method='scale')))
``` 

## Q11a - Python
```{python}
# 11. Function 8: Plot Feature

def plot_feature(df, col, plot_type):
    plt.figure(figsize=(10, 6))
    
    if plot_type == 'hist':
        df[col].hist(bins=25)
        plt.title(f'Histogram of {col}')
        plt.xlabel(col)
        plt.ylabel('Frequency')
        plt.tight_layout()
    
    elif plot_type == 'box':
        df.boxplot(column=[col])
        plt.title(f'Boxplot of {col}')
        plt.ylabel(col)
    
    elif plot_type == 'bar':
        df[col].value_counts().plot(kind='bar')
        plt.title(f'Bar Chart of {col}')
        plt.xlabel(col)
        plt.ylabel('Count')
    
    else:
        raise ValueError("Unsupported plot type. Use 'hist', 'box', or 'bar'.")
    
    plt.show()

# Test the function
plot_feature(df, 'Price', 'hist')
plot_feature(df, 'Age', 'box')
plot_feature(df, 'Category', 'bar')
```

## Q11a - R
```{r}
#11. Function: Plot Feature

plot_feature <- function(df,col, plot_type){
    
    p<-ggplot(df,aes_string(x=col))+
        theme_minimal()+
        labs(title=paste(plot_type,"of",col),
             x=col,y="Frequency")
    
    if(plot_type=='hist'){
        p<-p+geom_histogram(binwidth=30,color="black",fill="blue")
        
    }else if(plot_type=='box'){
        p<-p+geom_boxplot(aes_string(y=col))+
            coord_flip()
        
    }else if(plot_type=='bar'){
        p<-p+geom_bar(color="black",fill="blue") + theme(axis.text.x = element_text(angle = 45, hjust = 1))
        
    }else{
        stop("Unsupported plot type.Use hist box or bar.")
        
    }
    
    print(p)
}

# Test the function
plot_feature(df,'Price','hist')
plot_feature(df,'Age','box')
plot_feature(df,'Category','bar')
``` 
# UDF & Iterations

## Q1
Here we calculated stuendent test scores by comparing there answers to the answer key. This was conducted with a basic loop and conditional statements in R and Python. Both students scores were then printed out to the terminal.

## Q2
Another loop was used in this question to calculate the costs when buying in bulk with different quantity prices.

## Q3
In the third question, an amortization schedule was made using a loop for the loan, printing out the annual balance. Instead of using the given monthly payment of $1493.33, I calculated the exact number so that the end balance was exactly at 0.

## Q4
A function was made that calculated the dot product between two lists. In this problem, it was much easier to utilize/solve with R instead of Python where I used a zip function.

## Q5
Here the function returns the index of the smallest value in a list. This also shows the difference between indexing in Python and R. To get the same output, I subtracted the R index by 1.

## Q6
This function returns the unique values in a list. This function also showcases how much clearer the readability of python is compared to R.

## Q7
Here we have a function that can calculate the mean and the weighted mean. I made the second value inputed into the funtion optional so that only one function is needed to perform either calculation.

## Q8
The intersection function made in this section finds what values in two different lists are the same. For example, intersecting both of the students answers would give us the questions that they answered the same on. This could be useful in a larger pool of data to see where many students need to improve in their studies.

## Q9
The load_data function allows us to import the data from external csv, txt, and xlsx files so that we can manipulate and show the data.

## Q10
The data that we loaded in is then cleaned with the clean_data function. It can drop missing values, fill in missing values, and scale columns. Values can be filled in by using the previous or next value. It can also use a 0 (none) or the mean.

## Q11
A function was made to take a data column and make a histogram, box-plot, or bar chart. In the example I used 'price' for the histogram, 'age' for the box-plot, and 'category' for the bar graph.

## Summary & Reflection

### Main differences in syntax and functionality:
There are many differences between R and Python. First is quite obviously the syntax. For example, a 'for loop' in Python is 'for item in collection' while R is 'for (item in collection).' Another example is when defining a function in Python, the keyworkd 'def' has to be put in front while R uses 'function' instead. FInally, the indexing between R and Python are also different. R uses 1-based indexing while Python uses 0-based indexing. Through experience that I've gained in labs, R feels more natural when manipulating datasets while Python is much easier to read and understand someone else's work

### Challenges
I had some trouble with my data tyes in R when cleaning my data. However, it was my algorithm that was wrong and I just needed to look at it from a different angle. I also was tripped up because I forgot that the indexing between the two languages is different. I felt that for the beginning questions, Python was easy and intuitive to use. For the later questions, I was more comfortable manipulating the data with R. R is also much better at plotting since using ggplot provides a lot of different functionality.

### Deciding which language to use:
When choosing a language, I think that the most important part is what project you are working on. If statistical analysis is heavily used, I would program in R. In a professional environment, it should also be whatever your team is most used to coding in. Another factor could be the libraries that are included for each language. Some libraries could be much more efficient for the task than others. Personally, I find that I code faster in Python since it is faster to write loops and functions. Python also has very well performing loops.

### Biblical Worldview
We need to be good stewards of the earth (Geneisis 2:15) which means that we should use our God given skills/talents to honor Him and for the benefit others. Thus, we must commit to honesty and integrity in our work. As we work, others should be able to see the character of Christ through our actions. Not only that, our work should be a form of worship where we can gorify good through our pursuit of knowledge in data science.




{{< pagebreak >}}

# References

###### Hendrickson Publishers. (2004). The holy Bible: King James Version.